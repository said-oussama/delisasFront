{"ast":null,"code":"// Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\nvar LETTERS = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\nexport function calculateDimensions(cells) {\n  var comparator = function comparator(a, b) {\n    return a - b;\n  };\n\n  var allRows = cells.map(function (cell) {\n    return cell.row;\n  }).sort(comparator);\n  var allCols = cells.map(function (cell) {\n    return cell.column;\n  }).sort(comparator);\n  var minRow = allRows[0];\n  var maxRow = allRows[allRows.length - 1];\n  var minCol = allCols[0];\n  var maxCol = allCols[allCols.length - 1];\n  return [{\n    row: minRow,\n    column: minCol\n  }, {\n    row: maxRow,\n    column: maxCol\n  }];\n} // Converts a letter coordinate to a digit coordinate.\n// Examples: \"A\" -> 1, \"B\" -> 2, \"Z\" -> 26, \"AA\" -> 27, etc.\n\nfunction columnLettersToNumber(columnLetters) {\n  // `for ... of ...` would require Babel polyfill for iterating a string.\n  var n = 0;\n  var i = 0;\n\n  while (i < columnLetters.length) {\n    n *= 26;\n    n += LETTERS.indexOf(columnLetters[i]);\n    i++;\n  }\n\n  return n;\n}\n\nexport function parseCellCoordinates(coords) {\n  // Coordinate examples: \"AA2091\", \"R988\", \"B1\".\n  coords = coords.split(/(\\d+)/);\n  return [// Row.\n  parseInt(coords[1]), // Column.\n  columnLettersToNumber(coords[0].trim())];\n}","map":{"version":3,"sources":["C:/Users/user/Desktop/fgs/front/fgs/node_modules/read-excel-file/modules/read/coordinates.js"],"names":["LETTERS","calculateDimensions","cells","comparator","a","b","allRows","map","cell","row","sort","allCols","column","minRow","maxRow","length","minCol","maxCol","columnLettersToNumber","columnLetters","n","i","indexOf","parseCellCoordinates","coords","split","parseInt","trim"],"mappings":"AAAA;AACA,IAAIA,OAAO,GAAG,CAAC,EAAD,EAAK,GAAL,EAAU,GAAV,EAAe,GAAf,EAAoB,GAApB,EAAyB,GAAzB,EAA8B,GAA9B,EAAmC,GAAnC,EAAwC,GAAxC,EAA6C,GAA7C,EAAkD,GAAlD,EAAuD,GAAvD,EAA4D,GAA5D,EAAiE,GAAjE,EAAsE,GAAtE,EAA2E,GAA3E,EAAgF,GAAhF,EAAqF,GAArF,EAA0F,GAA1F,EAA+F,GAA/F,EAAoG,GAApG,EAAyG,GAAzG,EAA8G,GAA9G,EAAmH,GAAnH,EAAwH,GAAxH,EAA6H,GAA7H,EAAkI,GAAlI,CAAd;AACA,OAAO,SAASC,mBAAT,CAA6BC,KAA7B,EAAoC;AACzC,MAAIC,UAAU,GAAG,SAASA,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0B;AACzC,WAAOD,CAAC,GAAGC,CAAX;AACD,GAFD;;AAIA,MAAIC,OAAO,GAAGJ,KAAK,CAACK,GAAN,CAAU,UAAUC,IAAV,EAAgB;AACtC,WAAOA,IAAI,CAACC,GAAZ;AACD,GAFa,EAEXC,IAFW,CAENP,UAFM,CAAd;AAGA,MAAIQ,OAAO,GAAGT,KAAK,CAACK,GAAN,CAAU,UAAUC,IAAV,EAAgB;AACtC,WAAOA,IAAI,CAACI,MAAZ;AACD,GAFa,EAEXF,IAFW,CAENP,UAFM,CAAd;AAGA,MAAIU,MAAM,GAAGP,OAAO,CAAC,CAAD,CAApB;AACA,MAAIQ,MAAM,GAAGR,OAAO,CAACA,OAAO,CAACS,MAAR,GAAiB,CAAlB,CAApB;AACA,MAAIC,MAAM,GAAGL,OAAO,CAAC,CAAD,CAApB;AACA,MAAIM,MAAM,GAAGN,OAAO,CAACA,OAAO,CAACI,MAAR,GAAiB,CAAlB,CAApB;AACA,SAAO,CAAC;AACNN,IAAAA,GAAG,EAAEI,MADC;AAEND,IAAAA,MAAM,EAAEI;AAFF,GAAD,EAGJ;AACDP,IAAAA,GAAG,EAAEK,MADJ;AAEDF,IAAAA,MAAM,EAAEK;AAFP,GAHI,CAAP;AAOD,C,CAAC;AACF;;AAEA,SAASC,qBAAT,CAA+BC,aAA/B,EAA8C;AAC5C;AACA,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,CAAC,GAAG,CAAR;;AAEA,SAAOA,CAAC,GAAGF,aAAa,CAACJ,MAAzB,EAAiC;AAC/BK,IAAAA,CAAC,IAAI,EAAL;AACAA,IAAAA,CAAC,IAAIpB,OAAO,CAACsB,OAAR,CAAgBH,aAAa,CAACE,CAAD,CAA7B,CAAL;AACAA,IAAAA,CAAC;AACF;;AAED,SAAOD,CAAP;AACD;;AAED,OAAO,SAASG,oBAAT,CAA8BC,MAA9B,EAAsC;AAC3C;AACAA,EAAAA,MAAM,GAAGA,MAAM,CAACC,KAAP,CAAa,OAAb,CAAT;AACA,SAAO,CAAC;AACRC,EAAAA,QAAQ,CAACF,MAAM,CAAC,CAAD,CAAP,CADD,EACc;AACrBN,EAAAA,qBAAqB,CAACM,MAAM,CAAC,CAAD,CAAN,CAAUG,IAAV,EAAD,CAFd,CAAP;AAGD","sourcesContent":["// Maps \"A1\"-like coordinates to `{ row, column }` numeric coordinates.\nvar LETTERS = [\"\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\nexport function calculateDimensions(cells) {\n  var comparator = function comparator(a, b) {\n    return a - b;\n  };\n\n  var allRows = cells.map(function (cell) {\n    return cell.row;\n  }).sort(comparator);\n  var allCols = cells.map(function (cell) {\n    return cell.column;\n  }).sort(comparator);\n  var minRow = allRows[0];\n  var maxRow = allRows[allRows.length - 1];\n  var minCol = allCols[0];\n  var maxCol = allCols[allCols.length - 1];\n  return [{\n    row: minRow,\n    column: minCol\n  }, {\n    row: maxRow,\n    column: maxCol\n  }];\n} // Converts a letter coordinate to a digit coordinate.\n// Examples: \"A\" -> 1, \"B\" -> 2, \"Z\" -> 26, \"AA\" -> 27, etc.\n\nfunction columnLettersToNumber(columnLetters) {\n  // `for ... of ...` would require Babel polyfill for iterating a string.\n  var n = 0;\n  var i = 0;\n\n  while (i < columnLetters.length) {\n    n *= 26;\n    n += LETTERS.indexOf(columnLetters[i]);\n    i++;\n  }\n\n  return n;\n}\n\nexport function parseCellCoordinates(coords) {\n  // Coordinate examples: \"AA2091\", \"R988\", \"B1\".\n  coords = coords.split(/(\\d+)/);\n  return [// Row.\n  parseInt(coords[1]), // Column.\n  columnLettersToNumber(coords[0].trim())];\n}\n"]},"metadata":{},"sourceType":"module"}