import { Directive, Input, HostBinding, HostListener, NgModule } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/platform-browser';
const isJsons = (array) => Array.isArray(array) &&
    array.every(row => typeof row === 'object' && !(row instanceof Array));
const isArrays = (array) => Array.isArray(array) && array.every(row => Array.isArray(row));
function jsonsHeaders(array) {
    return Array.from(new Set(array.map(item => Object.keys(item)).reduce((a, b) => [...a, ...b], [])));
}
function jsons2arrays(jsons, headers) {
    headers = headers || jsonsHeaders(jsons);
    // allow headers to have custom labels, defaulting to having the header data key be the label
    let headerLabels = headers;
    let headerKeys = headers;
    if (isJsons(headers)) {
        headerLabels = headers.map(header => header.label);
        headerKeys = headers.map(header => header.key);
    }
    const data = jsons.map(object => headerKeys.map(header => (header in object ? object[header] : '')));
    return [headerLabels, ...data];
}
const elementOrEmpty = (element) => element || element === 0 ? element : '';
function joiner(data, delimiter = ',') {
    return data
        .map((row, index) => row.map((element) => '"' + elementOrEmpty(element) + '"').join(delimiter))
        .join(`\n`);
}
function arrays2csv(data, headers, delimiter) {
    return joiner(headers ? [headers, ...data] : data, delimiter);
}
function jsons2csv(data, headers, delimiter) {
    return joiner(jsons2arrays(data, headers), delimiter);
}
function string2csv(data, headers, delimiter) {
    return headers ? `${headers.join(delimiter)}\n${data}` : data;
}
function toCSV(data, headers, delimiter) {
    if (isJsons(data)) {
        return jsons2csv(data, headers, delimiter);
    }
    if (isArrays(data)) {
        return arrays2csv(data, headers, delimiter);
    }
    if (typeof data === 'string') {
        return string2csv(data, headers, delimiter);
    }
    throw new TypeError(`Data should be a "String", "Array of arrays" OR "Array of objects" `);
}
function blob(data, uFEFF = true, headers, delimiter) {
    const csv = toCSV(data, headers, delimiter);
    return new Blob([uFEFF ? '\uFEFF' : '', csv], { type: 'text/csv' });
}
function buildURI(data, uFEFF = true, headers, delimiter) {
    return URL.createObjectURL(blob(data, uFEFF, headers, delimiter));
}

class CsvDirective {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        /** the body of the csv */
        this.data = [];
        /** Set the seperator between values */
        this.delimiter = ',';
        /** adds a Byte order mark to setup the csv as UTF-8  */
        this.uFEFF = true;
        /** filename */
        this.download = 'data.csv';
        this.target = this.isIEBrowser() ? '' : '_blank';
    }
    /** Set the filename of the csv. Default is `data.csv` */
    set filename(a) {
        this.download = a;
    }
    onClick() {
        // IE handling
        if (this.isIEBrowser()) {
            const file = blob(this.data, this.uFEFF, this.headers, this.delimiter);
            window.navigator.msSaveBlob(file, this.download);
        }
    }
    isIEBrowser() {
        return !!window.navigator.msSaveOrOpenBlob;
    }
    ngOnChanges() {
        this.href = this.sanitizer.bypassSecurityTrustResourceUrl(buildURI(this.data, this.uFEFF, this.headers, this.delimiter));
    }
}
CsvDirective.ɵfac = function CsvDirective_Factory(t) { return new (t || CsvDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DomSanitizer)); };
CsvDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: CsvDirective, selectors: [["", "csvLink", ""]], hostVars: 3, hostBindings: function CsvDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function CsvDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("download", ctx.download)("target", ctx.target)("href", ctx.href, ɵngcc0.ɵɵsanitizeUrlOrResourceUrl);
    } }, inputs: { data: "data", delimiter: "delimiter", uFEFF: "uFEFF", target: "target", filename: "filename", headers: "headers" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
CsvDirective.ctorParameters = () => [
    { type: DomSanitizer }
];
CsvDirective.propDecorators = {
    data: [{ type: Input }],
    headers: [{ type: Input }],
    delimiter: [{ type: Input }],
    filename: [{ type: Input }],
    uFEFF: [{ type: Input }],
    href: [{ type: HostBinding }],
    download: [{ type: HostBinding }],
    target: [{ type: Input }, { type: HostBinding }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CsvDirective, [{
        type: Directive,
        args: [{ selector: '[csvLink]' }]
    }], function () { return [{ type: ɵngcc1.DomSanitizer }]; }, { data: [{
            type: Input
        }], delimiter: [{
            type: Input
        }], uFEFF: [{
            type: Input
        }], download: [{
            type: HostBinding
        }], target: [{
            type: Input
        }, {
            type: HostBinding
        }], filename: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], href: [{
            type: HostBinding
        }], headers: [{
            type: Input
        }] }); })();

class CsvModule {
}
CsvModule.ɵfac = function CsvModule_Factory(t) { return new (t || CsvModule)(); };
CsvModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: CsvModule });
CsvModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CsvModule, [{
        type: NgModule,
        args: [{
                declarations: [CsvDirective],
                exports: [CsvDirective]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CsvModule, { declarations: [CsvDirective], exports: [CsvDirective] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { CsvDirective, CsvModule, arrays2csv, blob, buildURI, elementOrEmpty, isArrays, isJsons, joiner, jsons2arrays, jsons2csv, jsonsHeaders, string2csv, toCSV };

//# sourceMappingURL=ctrl-ngx-csv.js.map