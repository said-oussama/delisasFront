{"version":3,"file":"swal.component.d.ts","sources":["swal.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { AfterViewInit, EventEmitter, OnChanges, OnDestroy, OnInit, SimpleChanges } from '@angular/core';\nimport Swal, { SweetAlertOptions, SweetAlertResult, SweetAlertUpdatableParameters } from 'sweetalert2';\nimport * as events from './swal-events';\nimport { SweetAlert2LoaderService } from './sweetalert2-loader.service';\n/**\n * <swal> component. See the README.md for usage.\n *\n * It contains a bunch of @Inputs that have a perfect 1:1 mapping with SweetAlert2 options.\n * Their types are directly coming from SweetAlert2 types defintitions, meaning that ngx-sweetalert2 is tightly coupled\n * to SweetAlert2, but also is type-safe.\n *\n * (?) If you want to use an object that declares the SweetAlert2 options all at once rather than many @Inputs,\n *     take a look at [swalOptions], that lets you pass a full {@link SweetAlertOptions} object.\n *\n * (?) If you are reading the TypeScript source of this component, you may think that it's a lot of code.\n *     Be sure that a lot of this code is types and Angular boilerplate. Compiled and minified code is much smaller.\n *     If you are really concerned about performance and/or don't care about the API and its convenient integration\n *     with Angular (notably change detection and transclusion), you may totally use SweetAlert2 natively as well ;)\n *\n * /!\\ Some SweetAlert options aren't @Inputs but @Outputs: onBeforeOpen, onOpen, onClose, onAfterClose and onDestroy\n *     (but without \"on*\" prefix to respect community standards).\n *     However, preConfirm and inputValidator are still @Inputs because there are not event handlers, there can't be\n *     multiple listeners and we need the values they can/must return.\n */\nexport declare class SwalComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy {\n    private readonly sweetAlert2Loader;\n    private readonly moduleLevelFireOnInit;\n    private readonly moduleLevelDismissOnDestroy;\n    title: SweetAlertOptions['title'];\n    titleText: SweetAlertOptions['titleText'];\n    text: SweetAlertOptions['text'];\n    html: SweetAlertOptions['html'];\n    footer: SweetAlertOptions['footer'];\n    icon: SweetAlertOptions['icon'];\n    iconHtml: SweetAlertOptions['iconHtml'];\n    backdrop: SweetAlertOptions['backdrop'];\n    toast: SweetAlertOptions['toast'];\n    target: SweetAlertOptions['target'];\n    input: SweetAlertOptions['input'];\n    width: SweetAlertOptions['width'];\n    padding: SweetAlertOptions['padding'];\n    background: SweetAlertOptions['background'];\n    position: SweetAlertOptions['position'];\n    grow: SweetAlertOptions['grow'];\n    showClass: SweetAlertOptions['showClass'];\n    hideClass: SweetAlertOptions['hideClass'];\n    customClass: SweetAlertOptions['customClass'];\n    timer: SweetAlertOptions['timer'];\n    timerProgressBar: SweetAlertOptions['timerProgressBar'];\n    /** @deprecated Use showClass and hideClass instead */\n    animation: SweetAlertOptions['animation'];\n    heightAuto: SweetAlertOptions['heightAuto'];\n    allowOutsideClick: SweetAlertOptions['allowOutsideClick'];\n    allowEscapeKey: SweetAlertOptions['allowEscapeKey'];\n    allowEnterKey: SweetAlertOptions['allowEnterKey'];\n    stopKeydownPropagation: SweetAlertOptions['stopKeydownPropagation'];\n    keydownListenerCapture: SweetAlertOptions['keydownListenerCapture'];\n    showConfirmButton: SweetAlertOptions['showConfirmButton'];\n    showCancelButton: SweetAlertOptions['showCancelButton'];\n    confirmButtonText: SweetAlertOptions['confirmButtonText'];\n    cancelButtonText: SweetAlertOptions['cancelButtonText'];\n    confirmButtonColor: SweetAlertOptions['confirmButtonColor'];\n    cancelButtonColor: SweetAlertOptions['cancelButtonColor'];\n    confirmButtonAriaLabel: SweetAlertOptions['confirmButtonAriaLabel'];\n    cancelButtonAriaLabel: SweetAlertOptions['cancelButtonAriaLabel'];\n    buttonsStyling: SweetAlertOptions['buttonsStyling'];\n    reverseButtons: SweetAlertOptions['reverseButtons'];\n    focusConfirm: SweetAlertOptions['focusConfirm'];\n    focusCancel: SweetAlertOptions['focusCancel'];\n    showCloseButton: SweetAlertOptions['showCloseButton'];\n    closeButtonHtml: SweetAlertOptions['closeButtonHtml'];\n    closeButtonAriaLabel: SweetAlertOptions['closeButtonAriaLabel'];\n    showLoaderOnConfirm: SweetAlertOptions['showLoaderOnConfirm'];\n    preConfirm: SweetAlertOptions['preConfirm'];\n    imageUrl: SweetAlertOptions['imageUrl'];\n    imageWidth: SweetAlertOptions['imageWidth'];\n    imageHeight: SweetAlertOptions['imageHeight'];\n    imageAlt: SweetAlertOptions['imageAlt'];\n    inputPlaceholder: SweetAlertOptions['inputPlaceholder'];\n    inputValue: SweetAlertOptions['inputValue'];\n    inputOptions: SweetAlertOptions['inputOptions'];\n    inputAutoTrim: SweetAlertOptions['inputAutoTrim'];\n    inputAttributes: SweetAlertOptions['inputAttributes'];\n    inputValidator: SweetAlertOptions['inputValidator'];\n    validationMessage: SweetAlertOptions['validationMessage'];\n    progressSteps: SweetAlertOptions['progressSteps'];\n    currentProgressStep: SweetAlertOptions['currentProgressStep'];\n    progressStepsDistance: SweetAlertOptions['progressStepsDistance'];\n    scrollbarPadding: SweetAlertOptions['scrollbarPadding'];\n    /**\n     * An object of SweetAlert2 native options, useful if:\n     *  - you don't want to use the @Inputs for practical/philosophical reasons ;\n     *  - there are missing @Inputs because ngx-sweetalert2 isn't up-to-date with SweetAlert2's latest changes.\n     *\n     * /!\\ Please note that setting this property does NOT erase what has been set before unless you specify the\n     *     previous properties you want to erase again.\n     *     Ie. setting { title: 'Title' } and then { text: 'Text' } will give { title: 'Title', text: 'Text' }.\n     *\n     * /!\\ Be aware that the options defined in this object will override the @Inputs of the same name.\n     */\n    set swalOptions(options: SweetAlertOptions);\n    /**\n     * Computes the options object that will get passed to SweetAlert2.\n     * Only the properties that have been set at least once on this component will be returned.\n     * Mostly for internal usage.\n     */\n    get swalOptions(): SweetAlertOptions;\n    /**\n     * Whether to fire the modal as soon as the <swal> component is created and initialized in the view.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `false`.\n     *\n     * Example:\n     *     <swal *ngIf=\"error\" [title]=\"error.title\" [text]=\"error.text\" icon=\"error\" [swalFireOnInit]=\"true\"></swal>\n     */\n    swalFireOnInit?: boolean;\n    /**\n     * Whether to dismiss the modal when the <swal> component is destroyed by Angular (for any reason) or not.\n     * When left undefined (default), the value will be inherited from the module configuration, which is `true`.\n     */\n    swalDismissOnDestroy?: boolean;\n    set swalVisible(visible: boolean);\n    get swalVisible(): boolean;\n    /**\n     * Emits an event when the modal DOM element has been created.\n     * Useful to perform DOM mutations before the modal is shown.\n     */\n    readonly beforeOpen: EventEmitter<events.BeforeOpenEvent>;\n    /**\n     * Emits an event when the modal is shown.\n     */\n    readonly open: EventEmitter<events.OpenEvent>;\n    /**\n     * Emits an event when the modal DOM is rendered.\n     */\n    readonly render: EventEmitter<events.RenderEvent>;\n    /**\n     * Emits an event when the modal will be closed.\n     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.\n     */\n    readonly close: EventEmitter<events.CloseEvent>;\n    /**\n     * Emits an event after the modal had been closed.\n     * If you just want to know when the user dismissed the modal, prefer the higher-level (cancel) output.\n     */\n    readonly afterClose: EventEmitter<void>;\n    /**\n     * Emits an event after the modal had been closed.\n     * The difference between {@link destroy} and {@link afterClose} is that the latter is called for user interactions\n     * only (clicks), whereas {@link destroy} is always called, both for user interactions and popup being closed by\n     * another popup.\n     */\n    readonly destroy: EventEmitter<void>;\n    /**\n     * Emits when the user clicks \"Confirm\".\n     * Bears a value when using \"input\", resolved \"preConfirm\", etc.\n     *\n     * Example:\n     *     <swal (confirm)=\"handleConfirm($event)\"></swal>\n     *\n     *     public handleConfirm(email: string): void {\n     *         // ... save user email\n     *     }\n     */\n    readonly confirm: EventEmitter<any>;\n    /**\n     * Emits when the user clicks \"Cancel\", or dismisses the modal by any other allowed way.\n     * By default, it will emit a string representing the reason for which the SweetAlert has been closed.\n     * The reason is `undefined` when {@link dismiss} is called.\n     *\n     * Example:\n     *     <swal (cancel)=\"handleCancel($event)\"></swal>\n     *\n     *     public handleCancel(reason: DismissReason | undefined): void {\n     *         // reason can be 'cancel', 'overlay', 'close', 'timer' or undefined.\n     *         // ... do something\n     *     }\n     */\n    readonly cancel: EventEmitter<Swal.DismissReason | undefined>;\n    /**\n     * This Set retains the properties that have been changed from @Inputs, so we can know precisely\n     * what options we have to send to {@link Swal.fire}.\n     */\n    private readonly touchedProps;\n    /**\n     * A function of signature `(propName: string): void` that adds a given property name to the list of\n     * touched properties, ie. {@link touchedProps}.\n     */\n    private readonly markTouched;\n    /**\n     * Is the SweetAlert2 modal represented by this component currently opened?\n     */\n    private isCurrentlyShown;\n    constructor(sweetAlert2Loader: SweetAlert2LoaderService, moduleLevelFireOnInit: boolean, moduleLevelDismissOnDestroy: boolean);\n    /**\n     * Angular lifecycle hook.\n     * Asks the SweetAlert2 loader service to preload the SweetAlert2 library, so it begins to be loaded only if there\n     * is a <swal> component somewhere, and is probably fully loaded when the modal has to be displayed,\n     * causing no delay.\n     */\n    ngOnInit(): void;\n    /**\n     * Angular lifecycle hook.\n     * Fires the modal, if the component or module is configured to do so.\n     */\n    ngAfterViewInit(): void;\n    /**\n     * Angular lifecycle hook.\n     * Updates the SweetAlert options, and if the modal is opened, asks SweetAlert to render it again.\n     */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * Angular lifecycle hook.\n     * Closes the SweetAlert when the component is destroyed.\n     */\n    ngOnDestroy(): void;\n    /**\n     * Shows the SweetAlert.\n     *\n     * Returns the SweetAlert2 promise for convenience and use in code behind templates.\n     * Otherwise, (confirm)=\"myHandler($event)\" and (cancel)=\"myHandler($event)\" can be used in templates.\n     */\n    fire(): Promise<SweetAlertResult>;\n    /**\n     * Closes the modal, if opened.\n     *\n     * @param result The value that the modal will resolve with, triggering either (confirm) or (cancel).\n     *               If the argument is not passed, (dimiss) will emit `undefined`.\n     *               See {@link Swal.close}\n     */\n    dismiss(result?: SweetAlertResult): Promise<void>;\n    /**\n     * Updates SweetAlert2 options while the modal is opened, causing the modal to re-render.\n     * If the modal is not opened, the component options will simply be updated and that's it.\n     *\n     * /!\\ Please note that not all SweetAlert2 options are updatable while the modal is opened.\n     *\n     * @param options\n     */\n    update(options?: Pick<SweetAlertOptions, SweetAlertUpdatableParameters>): Promise<void>;\n}\n"]}